进程和多线程：
currentThread（）方法：方法可以返回代码段正在被那个线程调用的信息。
isAlive（）方法：是判断当前线程是否处于活动状态。
sleep（）方法：作用是在指定的毫秒数内让当前“正在执行的线程”休眠。这个正在执行的线程是指this.currrntThread（）返回的线程。
getId（）方法：是获取现成的唯一标识。
interrupt（）方法：中断线程。这个方法并不是立马停止循环。调用interrupt（）方法只是在当前线程中打了一个停止的标记，并不是真的停止线程。
判断线程是否是停止的：
在Thread.java类中提供了两种方法
1，this.interrupted():测试当前线程是否已经中断（static的）。
就是判断当前线程是否停止，线程的中断状态有该方法清除。换句话说，如果连续两次执行该方法，则第二次调用将返回false（在第一次调用已经清楚了其中中断状态之后，且第二次调用检验完中断状态之前，
当前线程再次中断的情况除外）文档已经解释的很清楚，interrupted（）方法具有清除状态的功能，所以第二次调用interrupted（）方法返回的值是false。
2，this.isInterrupted()：测试线程是否已经中断（非static的）。
首先，这个可以得到别的线程是否已经中断，并且isInterrupted（）方法并不清除状态标志。所以如果线程已经中断，就算连着判断两次也都是true。
最后总结一下：
1，this.interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志置清除为false的功能。（this是当前线程）
2，this.isInterrupted():测试this线程对象是否已经中断，但不清除状态。（this也可以是别的线程，并不一定是当前线程)
遇到异常也会停止线程：进入catch。
在沉睡中停止：如果在sleep状态下，停止某一线程，会进入catch语句，并且清除停止状态，使之变成false。
暴力的停止线程：调用stop（）方法，调用stop方法时会抛出java.lang.ThreadDeath异常，但在通常情况下，此异常不用显示的捕捉。并且强制stop会造成数据不一致。
使用return停止线程：将interrupt（）与return结合使用也能实现停止线程的效果。
不过还是建议使用“抛异常”的方法来实现现成的停止，就是在使用interrupted判断是否停止，如果停止就抛出异常。
暂停线程：
在java中可以使用suspend（）方法暂停线程，使用resume（）方法恢复线程。
缺点：容易造成公共方法的独占，是的其他线程无法访问公共同步对象。并且也容易出现因为线程的暂停而导致数据不同步的情况。
yield方法：
作用是放弃当前的cpu资源，将他让给其他任务去占用cpu执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得cpu时间片。
程序的优先级：
在操作系统中，线程可以划分优先级，优先级高的线程得到的cpu资源较多，也就是cpu优先执行优先级较高的线程对象中的任务。
设置线程的优先级使用setPriority（）方法。
高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部执行完。优先级具有随机性。