线程安全与锁优化
不可变：
在java语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都
不需要在采取任何的线程安全保障措施。
线程安全的实现方法：
互斥同步：
是一种常见的并发正确性保障手段。最基本的手段就是synchronized关键字。
非阻塞同步：
互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻
塞同步。随着硬件指令集的发展，我们有了另一个选择：基于冲突检测的乐观并发策略，通
俗的说就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据
有争用，产生了冲突，就再采用其他补偿措施。
锁优化：
高效并发是从jdk1.5到1.6的一个重要改进，花了大量的精力去实现各种锁优化技术，如适应锁自
旋，锁消除，锁粗话，轻量级锁和偏向锁等，这些技术都是为了在线程间更高效的共享数据以及
解决竞争问题，从而提高程序的执行效率。
自旋锁与自适应自旋：
共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。自旋本来虽然避免了线程间切换的开销，但他要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会特别好，反之，如果锁被占用的时间很长，那么自选的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，金应当使用传统的方式去挂起线程。
在jdk1.6中引入了自适应的自旋锁。自适应意味着自选的时间不在固定了，而是由前一次在同一个锁上的自选时间及锁的拥有者的状态来决定。
锁消除：
是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能残在共享数据的
锁进行消除。锁消除的主要依据来源于逃逸分析的数据支持，如果判断在一段代码中，对上的所
有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当成站上数据对待，认为他们是
线程私有的，同步加锁自然也就无须进行。
锁粗化：
轻量级锁：
偏向锁：