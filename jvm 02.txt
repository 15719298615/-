java内存区域与内存溢出异常
2019.10.10
java虚拟机所管理的内存将会包括以下几个运行时数据区域：

程序计数器：
*可看作是当前线程所执行的字节码的行为指示器。
*字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分
支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。
*为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条
线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
*如果线程执行的是一个java方法，这个计数器记录的正是执行的虚拟机字节码指令的地址。
*如果执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在java虚拟机规范
中没有规定任何OutOfMemoryError情况的区域。
java虚拟机栈：
*java虚拟机也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是java方法执行的
内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态
链表，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机
中入栈到出栈的过程。
*栈就是这里的虚拟机栈，或者说是虚拟机栈中局部变量表部分。
*局部变量表存放了编译期可知的各种数据类型（boolean，byte，char，short，int，float，
long，double），对象引用（reference类型，不等同于对象本身，可能是一个指向对象起始
地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和
retuenAddress类型（指向一条字节码指令的地址）
*局部变量表所需的内存空间在编译器间完成分配，当进入一个方法时，这个方法需要在帧中
分配多大的局部变量空间是完全确定的，编译期间是不会改变局部变量的大小的。
*在java虚拟机规范中，对这个区域规定了两种异常状况：1.如果线程请求的栈深度大于虚拟
机所允许的深度，将抛出StackOverflowError异常；如虚拟机可以动态扩展，如果虚拟机扩
展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
本地方法栈：
*本地方法栈与虚拟机栈所发挥的作用时非常相似的，它们之间的区别不过是虚拟机栈为虚拟
机执行java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服
务。
java堆:
*java堆是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区
域，在虚拟机启动时创建。此内存区域的唯一的目的就是存放对象实例，几乎所有的对象实
例都在这里分配内存。
*java虚拟机规范的描述是：所有的对象实例以及数组都要在堆上进行分配，但是随着jit编译
器的发展与逃逸分析技术，栈上分配，标量替换优化技术将会导致一些微妙的变化，所有对
象都在堆上分配变得不那么绝对了。
*java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。
*因为现在收集器基本采用分代收集算法，所以Java堆中还可以细分为新生代和老年代；再
细致一点还有Eden空间，From Servivor空间，To Survivor空间等。
*java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。
*如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出OutOfMemoryError
异常。
方法区：
*方法区与java堆一样，是各个线程共享的内存区域，他用于存储已经被虚拟机加载的类信
息，常量，静态变量，即时编译器编译后的代码等数据。
*jdk1.7的hotspot中，把原本放在永久代的字符串常量池移出。
*当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
运行时常量池：
*运行时常量池是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述
信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，部分内容
将在类加载后进入方法区的运行时常量池中存放。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 	 
*运行时常量池相对于Class文件常量池的另一个重要特性就是具备动态性，java语言并不要
求一定只有编译器才能产生，也就是并非预制入Class文件中常量池的内容才能进入方法区
运行时常量池，运行期间也可能将新的常量放入池中。这种特性被利用的较多的是String类
的intern（）方法。
*intern() 方法
intern() 方法
返回字符串对象的规范化表示形式。
intern()是把堆中的引用丢入常量池中，然后返回这个引用。当常量池中已经存在这个引用，就直接返回这个引用。
它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，
s.intern() == t.intern() 才为 true。
返回值
一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池。
实例
public class Test {
    public static void main(String args[]) {
        String Str1 = new String("www.runoob.com");
        String Str2 = new String("WWW.RUNOOB.COM");

        System.out.print("规范表示:" );
        System.out.println(Str1.intern());

        System.out.print("规范表示:" );
        System.out.println(Str2.intern());
    }
}
以上程序执行结果为：
规范表示:www.runoob.com
规范表示:WWW.RUNOOB.COM

直接内存：
*基于通道与缓冲区的I/O方式，它可以使用native函数库直接分配堆外内存，然后通过一个存储在
java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能够在一些场景中显著的提
高性能，因为避免了在java堆和Native堆中来回复制主句。
对象的创建：
*java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
*因此，在使用Seria，ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞。
*而在使用CMS这种基于Mark-Sweep算法的手机器时，通常采用空闲列表。
*但是对象爱创建在虚拟机中是非常频繁的，在并发情况下线程并不安全。解决方案由两种：
1.堆分配内存空间的动作进行同步处理-实际上是采用Cas配上失败重试的方式保证更新操作的原
子性。2.二是把每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。那
个线程需要分配内存，就在那个线程的TALB上分配，只有TALB用完并分配新的TALB时，才需要
同步锁定。
对象的布局：
*在HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头，实例数据和对齐填
充。
*而对象头包括两个部分：1.存储对象自身的运行时数据，如哈希码，GC反代年龄，所状态标
志，线程持有的锁，偏向线程ID，偏向时间戳。2.类型指针，即对象指向它的类元数据的指针，
虚拟机通过这个指针来确定这个对象时那个类的实例。
*实例数据：时对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。
*对齐填充：并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用，当对象实例数据部
分没有对齐时，就要通过对齐填充来补全。
对象的访问定位：
*建立对象是为了使用对象，java程序需要通过栈上的reference数据来操作堆上的具体对象。
*由于reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应
该通过何种方式区定位，访问堆中的对象的具体位置所以对象访问方法也是取决于虚拟机实现而
定的。目前主流的访问方式有使用句柄和直接指针。
使用句柄：java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地
址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
直接指针：java堆对象的布局中就必须考虑如何放置直接访问类型数据的相关信息，而reference
中存储的直接就是对象的地址。
*这两种方式各有优势，使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在
对象被移动时只会改变句柄中的实例数据指针，而reference不用改。
*使用直接指针访问最大的好处就是速度更快，节省了一次指针定位的时间开销。而HotSpot使用
的是直接指针。而使用句柄访问的情况也非常常见。
方法区和运行时常量池溢出：
-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接地限制其中常量池的大小。
