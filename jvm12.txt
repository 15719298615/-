java内存模型与线程
2019.10.14
java内存模型：
java虚拟机规范中试图定义一种java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以
实现让java程序在各种平台下都能达到一致的内存访问效果。
主内存与工作内存：
*java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和
从内存中取出变量这样的底层细节。此处的变量与java编程中所说的变量有所区别，他包括了实
例字段，静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有
的，不会被共享。
*java内存模型规定了所有的变量都存储在主内存中。
内存间交互操作：（原子性）
线程，主内存，工作内存三者的交互关系图

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内粗拷贝到工作内存，如何从
工作内存同步回主内存之类的实现细节，java内存模型中定义了一下8种操作来完成，虚拟机实现
时必须保证下面提及的每一种操作都是原子的，不可再分的：
lock，锁定，所用于主内存变量，它把一个变量标识为一条线程独占的状态。
unlock，解锁，解锁后的变量才能被其他线程锁定。
read，读取，所用于主内存变量，它把一个主内存变量的值，读取到工作内存中。
load，载入，所用于工作内存变量，它把read读取的值，放到工作内存的变量副本中。
use，使用，作用于工作内存变量，它把工作内存变量的值传递给执行引擎，当JVM遇到一个变量读取指令就会执行这个操作。
assign，赋值，作用于工作内存变量，它把一个从执行引擎接收到的值赋值给工作内存变量。
store，存储，作用域工作内存变量，它把工作内存变量值传送到主内存中。
write，写入，作用于主内存变量，它把store从工作内存中得到的变量值写入到主内存变量中
如果要把一个变量从主内存复制到工作内存，那就要顺序的执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序的执行store和write操作。但是java内存模型只要求以上两个操作顺序执行，但没有要求必须是连续执行，也就是说指令之间可以插入其他的指令。除此之外，java内存模型还规定了在执行上述八种操作时必须满足如下八种规则：
8种操作的规则：
　　java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
不允许read和load、store和write操作之一单独出现，即不允许加载或同步工作到一半。
不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后，必须吧改变化同步回主内存。
不允许一个线程无原因地（无assign操作）把数据从工作内存同步到主内存中。
一个新的变量只能在主内存中诞生。
一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次lock之后，必须要执行相同次数的unlock操作，变量才会解锁。
如果对一个对象进行lock操作，那会清空工作内存变量中的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
如果一个变量事先没有被lock，就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁住的变量。
对一个变量执行unlock操作之前，必须将此变量同步回主内存中（执行store、write）。
有如上8种内存访问操作以及规则限定，再加上对volatile的一些特殊规定，就已经完全
确定了java程序中哪些内存访问操作是在并发下安全的。
对于volatile型变量的特殊规则（可见性,相当于一个gat、set方法）：
*关键字vilatile可以说是java虚拟机提供的最轻量级的同步机制。
*用一点简单的语言介绍一下这个关键字：
当一个变量定义为volatile之后，他将具备两种特性，第一是保证此变量对所有线程的可见
性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是立即得
知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，
比如线程a修改一个普通变量的值，然后向主存进行回写，另一条线程b在线程a回写完成了
之后再从主内存进行读取操作，新变量才会被b可见。
*但是java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。（在各个
线程工作内存中，volatile变量也可以存在不一致问题）
*由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍要通过加锁
（使用synchronized或java.util.concurrent中的原子类）来保证原子性。：
1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
2.变量不需要与其他的状态变量共同参与不变约束。
原子性，可见性，有序性：
*原子性：由java内存模型来直接保证的原子性变量操作包括read，load，assgin，use，
store，write，我们大致可以认为基本数据类型的访问读写是具有原子性的。
*可见性：是指当一个线程修改了一个共享变量的值，其他线程能够立即得到这个修改。java
内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种
依赖主内存作为媒介的方式来实行可见性的，无论是普通变量还是volatile变量都是如此，普
通变量与volatile变量都是如此，普通变量和volatile变量的区别是，volatile的特殊规则保证了
新值能立即同步到主内存，以及每次使用前从主内存刷新。因此，可以说volatile保证了多线
程操作时变量的可见性，而普通变量则不能保证这一点。
除了volatile外还有两个关键字能实现可见性，即synchronized和final。同步块是由于“对一个
变量执行unlock的操作之前，必须先把此变量同步回主内存中（执行store，write操作）”这
条规则获取的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完
成，并且构造器没有把this的引用传递出去，那在其他线程中就能看见final字段的值。
*有序性：java语言提供了volatile和synchroized两个关键字来保证线程之间操作的有序性，
volatile关键字本身就包括了禁止指令重排序的语句，而synchronized则是由“一个变量在同
一个时刻只允许一条线程对其进行lock操作”这条语句规则获得的，这条规则决定了持有同一
个锁的两个同步块只能穿行地进入。
状态转换：
新建，运行，无限等待，限期等待，阻塞，结束；
