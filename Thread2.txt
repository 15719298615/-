方法内部的变量为线程安全，方法中的变量不存在非线程安全问题，永远都是线程安全的。这是因为方法内部的变量时私有的特性造成的。
多个对象多个锁。
synchronized方法与锁对象：
关键字synchronized锁的是对象，电泳关键字synchronized生命的方法一定是排队运行的。并且
如果一个线程使用了锁定的方法另一个线程可以一部电泳非synchronized类型的方法。
最终结论：1，A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非
synchronized类型的方法。
   2，A线程先持有object对象的Lock锁，B线程如果在这时调用object对象中的
synchronized类型的方法则需要等待，也就是同步。
脏读：
发生脏读的情况就是在读取数据实例变量时，此值已经被其他线程更改过了。一般的情况就是给
set方法加了synchronized，但是get方法没有加synchronized。解决就是加上synchronized
synchronized锁重入：
*关键字synchronized拥有锁冲入的功能，也就是在使用synchronized时，当一个线程得到一个对
象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。这也证明了在一个synchronized方
法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。
*可重入锁的概念是：自己可以再次获取自己的内部锁。如果锁不可重入的话就会造成死锁。并且
可重入锁也支持在父子类继承的环境中。当存在父子类继承关系时，子类时完全可以通过“可重入
锁”调用父类的同步方法。
出现异常时，锁自动释放：	
当一个线程执行的代码出现异常时，其所吹有的锁会自动释放。比如线程A出现异常并释放锁，
线程B就会进入方法。
同步不具有继承性：
同步不能继承，想要继承还要在子类的方法中加入synchronized关键字。

synchronized同步语句块
*用synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间的
任务，那么B线程则必须等待比较长的时间。在这样的情况下可以使用synchronized同步语句块
来解决。synchronized方法是对当前对象进行加锁，而synchronized代码块时堆某一个对象进行
加锁。
synchronized同步代码块的使用：
一半同步一半异步：不在synchronized块中就是异步执行，在synchronized块中就是同步执行。
synchronized代码块间的同步性：
在使用synchronized（this）代码块时需要注意的是，当一个线程访问object的一个
synchronized（this）同步代码块时，其他线程堆同一个object中所有其他synchronized（this）
同步代码块的访问将被阻塞，这说明synchronized使用的“对象监视器”是一个。
synchronized和synchronized方法一样是锁定当前对象的。
锁定非this对象：
锁定非synchronized对象具有一定的优点：如果在一个类中有很多个synchronized方法，这时虽
然能实现同步，但会受到阻塞，所以影响运行效率；但如果使用同步代码块锁定非this对象，则
是异步的，步语其他锁this同步方法挣钱this锁，则可以大大提高运行效率。
静态同步synchronized方法与synchronized（class）代码块：
从运行结果来看，都是同步的效果。但是有本质的区别，synchronized关键字加到static静态方法
上是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。Class锁可以
对类的所有对象起到实例作用。synchronized（class）代码块的作用和synchronized static一
样。
数据类型String的常量池特性：
在大部分情况下synchronized代码块都不使用String作为锁对象。因为常量池的原因。
同步synchronized方法无限等待解决：
同步方法容易造成死循环。可以使用同步代码块来解决。
使用volatile关键字增加了实例变量在多个线程之间的可见性。但volatile的缺点是不支持原子性。
区别：
1，关键字volatile是线程同步的轻量级实现，所以volatile性能肯定要比synchronized好，并且
volatile只能修饰变量，而synchronized关键字可以修饰方法，以及代码块。
2，多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。
3，volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以
间接保证可见性，因为它会将私有内存和公有内存中的数据做同步。
4，再次重申，volatile解决的是变量在多个线程间的可见性。而synchronized解决的是多个线程
之间访问资源的同步性。

