 概念：
内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。将数据对象转化为二进制流的过程称为对象的序列化。反之，将二进制流恢复为数据对象的过程称为反序列化。
序列化需要保留充分的信息以恢复数据对象，但是为了节约存储空间和网络带宽，序列化后的二进制流又要尽可能的小。序列化常见的使用场景是RPC框架的数据传输。

常见的序列化分为三种：
1.java原生序列化：
java通过实现Seriali zable接口来实现该对象的序列化，这个接口非常特殊，没有任何方法，只起标识作用。java序列化保留了对象类的元数据（如类，成员变量，继承类信息等），以及对象数据等，兼容性最好，但不支持跨语言，而且性能一般。
建议设置serialVersionUID字段值。
2.Hessian序列化：
支持动态语言，跨语言，基于对象传输的网络协议。java对象序列化的二进制流可以被其他语言（如c++，Python）反序列化。并且比java原生序列化高效。
Hessian会把复杂对象所有属性存储在一个Map中进行序列化。所以在父类，子类同名成员变量的情况下，Hession序列化时，先序列化子类，然后序列化父类，因此反序列化结果会导致子类同名变量成员被父类的值覆盖。
3.json序列化：
JSON是一种轻量级的数据交换格式。JSON序列化就是讲数据对象转换为JSON字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确的反序列化。相比前两种方式JSON的可读性比较好，方便调试。
.
序列化的安全：
序列化通常会通过网络传输对象，而对象中往往有敏感数据，所以序列化常常成为黑客的攻击点，攻击者巧妙地利用反序列化过程后遭恶意代码，是的程序在反序列化的过程中执行任意代码。
如何防范这种攻击？有些对象的敏感属性不需要进行序列化传输，可以加transient关键字，避免把此属性信息转化为序列化的二进制流。如果一定要传递对象的敏感属性，可以使用对称与非对称健米防水独立传输，在使用某个方法把属性还原到对象中。
