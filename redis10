自动补齐最近联系人：
可以使用列表来存储元素。

分布式锁：
分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。
对程序进行”加锁“时，首先需要进行获取（acquire）锁来获取到锁，最后释放（release）锁。


方式一：
简易锁+同时可以设置所过期时间
缺点：
1.持有锁的进程会因为操作时间过长而导致锁被自动释放，但进程本身并不知晓这点，甚至有可能会错误的释放了其他进程持有的锁。
2.一个持有锁并打算长时间执行的进程崩溃，但其他想要获得锁的进程不知道那个进程持有锁，也无法检测出持有锁的进程已经崩溃，只能白白的浪费时间等待锁被释放。
3.在一个进程持有锁的锁过期之后，其他多个进程同时尝试去获得锁，并且同时获得了锁。
4.上面提到的第一种和第三种情况同时出现，导致有多个进程获得了锁，而每个进程都以为自己是唯一获得锁的进程。

方式二：
使用redis构建锁：
使用setnx来实现锁的获取功能，这个命令只会在键不存在的情况下为键设置值，而锁要做的就是讲一个随机生成的128位uuid设置为键的值，并使用这个值来防止锁被其他进程获得。

public abstract class RedisLock implements Lock {

    //...
    protected String lockValue;

    public RedisLock(Jedis jedis,String lockKey) {
        this(jedis, lockKey, UUID.randomUUID().toString()+Thread.currentThread().getId());
    }

    public RedisLock(Jedis jedis, String lockKey, String lockValue) {
        this.jedis = jedis;
        this.lockKey = lockKey;
        this.lockValue = lockValue;
    }

    //...
}

加锁代码
public void lock() {
    while(true){
        String result = jedis.set(lockKey, lockValue, NOT_EXIST,SECONDS,30);
        if(OK.equals(result)){
            System.out.println(Thread.currentThread().getId()+"加锁成功!");
            break;
        }
    }
}

解锁代码
public void unlock() {
    String lockValue = jedis.get(lockKey);
    if (lockValue.equals(lockValue)){
        jedis.del(lockKey);
    }
}

别的方式：
细颗粒度锁：
带有超时限制特性的锁：

计数信号量：
计数信号量是一种锁，他可以让用户限制一项资源最多能够同时被多少个进程访问。
进程在尝试获取信号量之前会生成一个标示符，并使用当前时间戳作为分值，将标示符添加到有序集合里。接着进程会检查自己的标示符在有序集合中的排名。如果排名低于可获取的信号量总数，那么表示进程成功的取得了信号量。反之，则表示进程为能获取信号量，他必须从有序集合里溢出自己的标示符。为了处理过期的信号量，程序在将标示符添加到有序集合之前，会清理有序集合中所有的时间戳大于超时数值的标示符。


公平信号量：
当各个系统的系统时间并不完全相同时，前面介绍的基本信号量就会出现问题：系统时间较慢的系统上运行的客户端，将能够偷走系统时钟较快的系统上运行的客户端已经获取的信号量导致信号量变的不公平。
为了尽可能的减少系统时间不一致带来的问题，我们需要给信号量实现添加一个计数器以及一个有序集合。其中，计数器通过持续的执行自增操作，创建出一种类似于计时器的机制，确保最先对计数器执行自增操作的客户端能够获得信号量。


任务队列：
