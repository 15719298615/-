自动补齐最近联系人：
可以使用列表来存储元素。

分布式锁：
分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。
对程序进行”加锁“时，首先需要进行获取（acquire）锁来获取到锁，最后释放（release）锁。


方式一：
简易锁+同时可以设置所过期时间
缺点：
1.持有锁的进程会因为操作时间过长而导致锁被自动释放，但进程本身并不知晓这点，甚至有可能会错误的释放了其他进程持有的锁。
2.一个持有锁并打算长时间执行的进程崩溃，但其他想要获得锁的进程不知道那个进程持有锁，也无法检测出持有锁的进程已经崩溃，只能白白的浪费时间等待锁被释放。
3.在一个进程持有锁的锁过期之后，其他多个进程同时尝试去获得锁，并且同时获得了锁。
4.上面提到的第一种和第三种情况同时出现，导致有多个进程获得了锁，而每个进程都以为自己是唯一获得锁的进程。

方式二：
使用redis构建锁：
使用setnx来实现锁的获取功能，这个命令只会在键不存在的情况下为键设置值，而锁要做的就是讲一个随机生成的128位uuid设置为键的值，并使用这个值来防止锁被其他进程获得。

public abstract class RedisLock implements Lock {

    //...
    protected String lockValue;

    public RedisLock(Jedis jedis,String lockKey) {
        this(jedis, lockKey, UUID.randomUUID().toString()+Thread.currentThread().getId());
    }

    public RedisLock(Jedis jedis, String lockKey, String lockValue) {
        this.jedis = jedis;
        this.lockKey = lockKey;
        this.lockValue = lockValue;
    }

    //...
}
