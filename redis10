自动补齐最近联系人：
可以使用列表来存储元素。

分布式锁：
分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。
对程序进行”加锁“时，首先需要进行获取（acquire）锁来获取到锁，最后释放（release）锁。


方式一：
简易锁+同时可以设置所过期时间
缺点：
1.持有锁的进程会因为操作时间过长而导致锁被自动释放，但进程本身并不知晓这点，甚至有可能会错误的释放了其他进程持有的锁。
2.一个持有锁并打算长时间执行的进程崩溃，但其他想要获得锁的进程不知道那个进程持有锁，也无法检测出持有锁的进程已经崩溃，只能白白的浪费时间等待锁被释放。
3.在一个进程持有锁的锁过期之后，其他多个进程同时尝试去获得锁，并且同时获得了锁。
4.上面提到的第一种和第三种情况同时出现，导致有多个进程获得了锁，而每个进程都以为自己是唯一获得锁的进程。

方式二：
使用redis构建锁：
使用setnx来实现锁的获取功能，这个命令只会在键不存在的情况下为键设置值，而锁要做的就是讲一个随机生成的128位uuid设置为键的值，并使用这个值来防止锁被其他进程获得。

public abstract class RedisLock implements Lock {

    //...
    protected String lockValue;

    public RedisLock(Jedis jedis,String lockKey) {
        this(jedis, lockKey, UUID.randomUUID().toString()+Thread.currentThread().getId());
    }

    public RedisLock(Jedis jedis, String lockKey, String lockValue) {
        this.jedis = jedis;
        this.lockKey = lockKey;
        this.lockValue = lockValue;
    }

    //...
}

加锁代码 
public void lock() {
    while(true){
        String result = jedis.set(lockKey, lockValue, NOT_EXIST,SECONDS,30);
        if(OK.equals(result)){
            System.out.println(Thread.currentThread().getId()+"加锁成功!");
            break;
        }
    }
}

解锁代码
public void unlock() {
    String lockValue = jedis.get(lockKey);
    if (lockValue.equals(lockValue)){
        jedis.del(lockKey);
    }
}

别的方式：
细颗粒度锁：
带有超时限制特性的锁：

计数信号量：
计数信号量是一种锁，他可以让用户限制一项资源最多能够同时被多少个进程访问。
进程在尝试获取信号量之前会生成一个标示符，并使用当前时间戳作为分值，将标示符添加到有序集合里。接着进程会检查自己的标示符在有序集合中的排名。如果排名低于可获取的信号量总数，那么表示进程成功的取得了信号量。反之，则表示进程为能获取信号量，他必须从有序集合里溢出自己的标示符。为了处理过期的信号量，程序在将标示符添加到有序集合之前，会清理有序集合中所有的时间戳大于超时数值的标示符。


公平信号量：
当各个系统的系统时间并不完全相同时，前面介绍的基本信号量就会出现问题：系统时间较慢的系统上运行的客户端，将能够偷走系统时钟较快的系统上运行的客户端已经获取的信号量导致信号量变的不公平。
为了尽可能的减少系统时间不一致带来的问题，我们需要给信号量实现添加一个计数器以及一个有序集合。其中，计数器通过持续的执行自增操作，创建出一种类似于计时器的机制，确保最先对计数器执行自增操作的客户端能够获得信号量。


任务队列：
在处理web客户端发送的命令请求时，某些操作的执行时间可能会比我们预期的更长一些。通过将待执行的任务的相关信息放在队列里面，并在之后对队列进行处理，用户可以推迟执行那些需要一段时间才能完成的操作这种将工作交给任务处理器来执行的做法被称为任务队列。现在有很多专门的任务队列软件（如ActiveMQ，RabbitMQ。。。。），另外在缺少专门的任务队列可用的情况下，也有一些临时性的方法可以创建任务队列。
接下来介绍两种不同类型的任务队列，第一种队列会根据任务被插入队列的顺序来尽快的执行任务，而第二种队列则具有安排任务在未来某个特定时间执行的能力。

先进先出队列：
使用redis的列表结构rpush及blpop（这个是阻塞板的弹出命令，从队列中弹出待发送的邮件，而命令罪的阻塞时限为30秒）

延迟任务：
实现方式：
1.在人物信息中包含任务的执行时间，如果工作进程发现任务的执行时间尚未来临，那么它将在短暂等待后，把任务重新推入队列里面。
2.工作进程使用一个本地的等待列表来记录所有需要在未来执行的任务，并在每次进行while循环时，检查等待队列表并执行那些已经到期的任务。
3.把所有需要在未来之星的任务都添加到有序集合里面，并将任务的执行时间设置为分值，另外在使用一个进程来查找有序集合里面是否存在可以立即被执行的任务，如果有的话，就从有续集和里面溢出那个任务，并将它添加到适当的任务队列里面。



