docker的三大特性：容器，镜像，仓库。
镜像/容器：eg ：Person p1 = new Person();
Person p2 = new Person();
Person就是镜像，而p1,p2就是容器。容器就是用镜像创建的运行实例。
它可以被启动，开始，停止，删除。每个容器都是相互隔离的，保证安全的平台。
可以把容器看作是一个简易版的Linux环境（包括root用户权限，进程空间，用户空间和网络空间）和运行在其中的应用程序。

仓库：仓库分为公开和私有的两种，是集中存放镜像的场所。
仓库和仓库注册服务器是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像又不同的标签。

虚拟机的缺点：
1.资源占用多
2.冗余步骤多
3.启动慢


面对虚拟机的这些缺点，linux发展出另一种虚拟化技术：Linux容器（Linux Containers，缩写为LXC）
Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆包一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效清零并保证部署在任何环境中的软件都能始终日益的运行。

Docker（秒级）和传统虚拟方案的不同之处：
1.传统虚拟机技术是虚拟出一套硬件系统，在其上运行一个完整的操作系统，在该操作系统上在运行所需的应用程序。
2.而容器内的应用进程直接运行于宿主的内核，在其上运行一个完整的操作系统，在该系统上再运行所需应用进程。
3.每个容器之间相互隔离，每个容器有自己的文件系统，容器之间进程不会互相影响，能区分计算资源。




run干了什么：
docker在本机中查找该镜像，如有该镜像就以该镜像为容器模板实例运行，若没有去Dockers Hub上查找该镜像，Hub上如果找到了就下载该镜像到本地以该镜像为模板生成容器实例，若没有就返回失败错误，查不到该镜像。


Docker是怎么工作的：
Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器，是一个运行时环境，就是我们前面说的集装箱。



为什么Docker比VM快：
1.docker比虚拟机有更少的抽象层。由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU，内存利用率上docker有着明显的优势。
2.docker用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。


docker命令：
dockers images	查看本地主机上的镜像。
docker search 名字（eg：docker search tomcat）（docker search -s 30 tomcat查找收藏数超过30的）			在docker hub上查找要用的镜像
dockers pull 名字（eg：docker pull tomcat）   在docker hub上拉默认最新版本：latest；写了版本号就拉那个版本。
docker rmi 名字			删除
docker ps    	查看当前运行了几个容器。
docker run -it --name 起个名字 要启动的容器的名字     		启动容器
exit		退出并关闭容器
ctrl+p+q		退出容器不关闭容器。
docker restart 容器Id    重启容器
docker stop 容器id/容器名		正常关闭容器，温柔的
docker kill 容器id/容器名			强制关闭容器，强制。
docker rm 容器id				删除已经停止的容器

可以把容器看作是一个简易版的Linux环境和运行在其中的应用程序。
更轻量：基于容器的虚拟化，仅包含业务运行所需的runtime环境。
